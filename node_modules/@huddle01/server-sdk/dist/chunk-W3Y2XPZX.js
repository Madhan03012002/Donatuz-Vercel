import { estimateSize } from './chunk-NAMYS2KV.js';
import { mainLogger } from './chunk-76CTSAYR.js';
import { MAX_METADATA_SIZE, INFRA_URL, SDK_VERSION } from './chunk-2ZBCNKEG.js';
import * as jose from 'jose';
import { z } from 'zod';

var logger = mainLogger.createSubLogger("AccessToken");
function isDefaultRole(role) {
  return Object.values(Role).includes(role);
}
var RoleSchema = z.union([
  z.literal("host"),
  z.literal("coHost"),
  z.literal("speaker"),
  z.literal("listener"),
  z.literal("guest"),
  z.literal("bot")
]);
var Role = {
  HOST: "host",
  CO_HOST: "coHost",
  SPEAKER: "speaker",
  LISTENER: "listener",
  GUEST: "guest",
  BOT: "bot"
};
var Permissions = z.object({
  admin: z.boolean(),
  canConsume: z.boolean(),
  canProduce: z.boolean(),
  canProduceSources: z.object({
    cam: z.boolean(),
    mic: z.boolean(),
    screen: z.boolean()
  }),
  canSendData: z.boolean(),
  canRecvData: z.boolean(),
  canUpdateMetadata: z.boolean()
});
var DEFAULT_PERMISSIONS = {
  admin: false,
  canConsume: true,
  canProduce: true,
  canProduceSources: {
    cam: true,
    mic: true,
    screen: true
  },
  canRecvData: true,
  canSendData: true,
  canUpdateMetadata: true
};
var ROLE_PERMISSIONS = {
  [Role.HOST]: {
    ...DEFAULT_PERMISSIONS,
    admin: true
  },
  [Role.CO_HOST]: {
    ...DEFAULT_PERMISSIONS,
    admin: true
    /* ... other permissions for the co-host ... */
  },
  [Role.LISTENER]: {
    admin: false,
    canConsume: true,
    canProduce: false,
    canProduceSources: {
      cam: false,
      mic: false,
      screen: false
    },
    canRecvData: true,
    canSendData: true,
    canUpdateMetadata: true
  },
  [Role.SPEAKER]: {
    admin: false,
    canConsume: true,
    canProduce: true,
    canProduceSources: {
      cam: false,
      mic: true,
      screen: true
    },
    canRecvData: true,
    canSendData: true,
    canUpdateMetadata: true
  },
  [Role.BOT]: {
    admin: false,
    canConsume: true,
    canProduce: false,
    canProduceSources: {
      cam: false,
      mic: false,
      screen: false
    },
    canRecvData: false,
    canSendData: false,
    canUpdateMetadata: false
  },
  [Role.GUEST]: {
    ...DEFAULT_PERMISSIONS
  }
};
var MeetingTokenInputSchema = z.object({
  roomId: z.string().min(1, {
    message: "RoomId must provided"
  }),
  muteOnEntry: z.boolean().optional(),
  videoOnEntry: z.boolean().optional(),
  roomType: z.enum(["AUDIO", "VIDEO"]).optional(),
  role: z.string().optional(),
  permissions: z.object({
    admin: z.boolean(),
    canConsume: z.boolean(),
    canProduce: z.boolean(),
    canProduceSources: z.object({
      cam: z.boolean(),
      mic: z.boolean(),
      screen: z.boolean()
    }),
    canSendData: z.boolean(),
    canRecvData: z.boolean(),
    canUpdateMetadata: z.boolean()
  }),
  ttl: z.number().optional(),
  metadata: z.string().optional(),
  options: z.object({
    maxPeersAllowed: z.number().optional()
  }).optional()
});
var AccessToken = class {
  apiKey;
  roomId;
  role;
  /**
   * Permissions for the token
   */
  permissions;
  /**
   * Token Options object
   *
   * - `ttl`: Time to live for the token or expiration time. can be a number of seconds or a string describing a time span zeit/ms
   *  @example  6 * 60 * 60, "2 days", "10h", "7d"`
   *  @default 4h
   *
   * - `maxPeersAllowed`:  Maximum number of peers allowed in the room (Optional)
   */
  options = {
    ttl: "4h"
  };
  /**
   * custom app data for the peer
   */
  metadata;
  constructor(data) {
    if (typeof document !== "undefined") {
      logger.error(
        "You should not include your API secret in your web client bundle.\n\nYour web client should request a token from your backend server which should then use "
      );
    }
    if (!data.apiKey) {
      throw new Error("api-key required");
    }
    if (!data.roomId) {
      throw new Error("roomId required");
    }
    if (data.options?.metadata && estimateSize(data.options?.metadata) > MAX_METADATA_SIZE) {
      throw new Error("Metadata size exceeds the limit of 5kb");
    }
    this.apiKey = data.apiKey;
    this.roomId = data.roomId;
    this.metadata = data.options?.metadata;
    if (data.options?.ttl) this.options.ttl = data.options?.ttl;
    if (data.options?.maxPeersAllowed !== void 0) {
      if (typeof data.options.maxPeersAllowed !== "number" || data.options.maxPeersAllowed <= 0) {
        throw new Error("maxPeersAllowed must be a positive number");
      }
    }
    if (data.options?.maxPeersAllowed) {
      this.options.maxPeersAllowed = data.options?.maxPeersAllowed;
    }
    if ("role" in data) {
      if (isDefaultRole(data.role) && !("permissions" in data)) {
        this.role = data.role;
        this.permissions = ROLE_PERMISSIONS[data.role];
      } else if (isDefaultRole(data.role) && "permissions" in data) {
        this.role = data.role;
        this.permissions = {
          ...ROLE_PERMISSIONS[data.role],
          ...data.permissions
        };
      } else if (typeof data.role === "string" && "permissions" in data) {
        if (data.role.length > 20) {
          throw new Error(`Custom role exceeds the limit of ${20} characters.`);
        }
        this.role = data.role;
        this.permissions = {
          ...DEFAULT_PERMISSIONS,
          ...data.permissions
        };
      } else {
        throw new Error(
          `Permissions must be provided for custom role: ${data.role}.`
        );
      }
    } else if ("permissions" in data) {
      this.permissions = {
        ...DEFAULT_PERMISSIONS,
        ...data.permissions
      };
    } else {
      throw new Error("Either a role or permissions must be provided.");
    }
  }
  set updatePermissions(permissions) {
    this.permissions = permissions;
  }
  set updateMetaData(data) {
    if (data && estimateSize(data) > MAX_METADATA_SIZE) {
      throw new Error("Metadata size exceeds the limit of 5kb");
    }
    this.metadata = data;
  }
  /**
   * Generate a JWT token
   * @returns JWT token
   * @example
   * ```typescript
   * const accessToken = new AccessToken({...})
   * accessToken.toJwt()
   * ```
   */
  async toJwt() {
    const payload = {
      roomId: this.roomId,
      permissions: this.permissions,
      role: this.role,
      metadata: JSON.stringify(this.metadata)
    };
    if (this.options?.maxPeersAllowed) {
      payload.options = {
        maxPeersAllowed: this.options.maxPeersAllowed
      };
    }
    const resp = await fetch(`${INFRA_URL}/api/v2/sdk/create-peer-token`, {
      method: "POST",
      body: JSON.stringify(payload),
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "Cache-Control": "no-store, max-age=0",
        Pragma: "no-cache",
        "x-sdk-version": SDK_VERSION
      }
    });
    if (resp.status === 401) {
      throw new Error("API key missing or invalid");
    }
    if (resp.status === 404) {
      throw new Error("Room not found to be associated with the given API key");
    }
    const { token } = await resp.json();
    return token;
  }
};
var TokenVerifier = class {
  JWKS;
  constructor() {
    this.JWKS = jose.createRemoteJWKSet(
      new URL("https://huddle01.app/jwks.json")
    );
  }
  /**
   * Verify a JWT token
   * @param token JWT token
   * @returns decoded token
   * @example
   * ```typescript
   * const verifier = new TokenVerifier()
   * verifier.verify(token)
   * ```
   * @throws {jose.errors.JWTExpired} if the token is expired
   * @throws {jose.errors.JWTClaimValidationFailed} if the token is invalid
   */
  async verify(token) {
    const { payload } = await jose.jwtVerify(token, this.JWKS);
    return payload;
  }
};

export { AccessToken, DEFAULT_PERMISSIONS, MeetingTokenInputSchema, Permissions, ROLE_PERMISSIONS, Role, RoleSchema, TokenVerifier, isDefaultRole };
